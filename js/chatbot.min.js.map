{"version":3,"file":"chatbot.min.js","sources":["chatbot.js"],"sourcesContent":["// Classe ChatBot para gerenciar a lógica do chat\r\nclass ChatBot {\r\n    constructor() {\r\n        try {\r\n            this.logger = new Logger();\r\n            // Inicializa elementos DOM e eventos\r\n            this.initDOMElements();\r\n            this.initDOMEvents();\r\n\r\n            // Inicializa o chat\r\n            this.questions = {};  // Objeto de perguntas\r\n            this.currentQuestion = 'start';\r\n            this.answers = {};\r\n            this.progressListeners = [];\r\n        } catch (error) {\r\n            this.logger.error(\"Erro ao inicializar o chat\", error);\r\n        }\r\n    }\r\n\r\n    /**\r\n   * Inicializa elementos do DOM.\r\n   */\r\n    initDOMElements() {\r\n        try {\r\n            this.chatWrapper = document.getElementById(\"mkt-chatbot-wrapper\");\r\n            this.chatIcon = this.chatWrapper.querySelector(\"#mkt-chatbot-icon\");\r\n            this.chatMain = this.chatWrapper.querySelector(\"#mkt-chatbot\");\r\n            this.minimizeButton = this.chatWrapper.querySelector(\"#mkt-chatbot-minimize\");\r\n            this.chatLog = this.chatWrapper.querySelector(\"#mkt-chatbot-log\");\r\n            this.inputArea = this.chatWrapper.querySelector(\"#mkt-chatbot-inputs\");\r\n        } catch (error) {\r\n            this.logger.error(\"Verifique se o elemento #mkt-chatbot-wrapper existe no DOM.\", error)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inicializa eventos do DOM.\r\n     */\r\n    initDOMEvents() {\r\n        try {\r\n            this.chatIcon.addEventListener(\"click\", () => this.openChat());\r\n            this.minimizeButton.addEventListener(\"click\", () => this.minimizeChat());\r\n        } catch (error) {\r\n            this.logger.error(\"Erro ao inicializar eventos do DOM\", error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inicia a conversa mostrando a primeira pergunta.\r\n     */\r\n    start() {\r\n        try {\r\n            this.showQuestion(this.currentQuestion);\r\n            this.chatWrapper.classList.remove(\"hidden\");\r\n        } catch (error) {\r\n            this.logger.error(\"Erro ao iniciar a conversa. Verifique se você adicionou pelo menos uma pergunta.\", error);\r\n        }\r\n    }\r\n\r\n    // Método para adicionar uma pergunta\r\n    addQuestion(key, text, type, choices = [], nextQuestion = null) {\r\n        if (this.questions[key]) {\r\n            this.logger.warn(`A pergunta com a chave ${key} já existe. A pergunta não será adicionada novamente.`);\r\n            return;\r\n        }\r\n\r\n        this.questions[key] = {\r\n            text, // isto pode ser uma string ou uma função\r\n            type,\r\n            choices,\r\n            nextQuestion // isto pode ser uma string ou uma função\r\n        };\r\n    }\r\n\r\n    // Método para adicionar um ouvinte de progresso\r\n    addProgressListener(listener) {\r\n        if (typeof listener === 'function') {\r\n            this.progressListeners.push(listener);\r\n        }\r\n    }\r\n\r\n    // Método para notificar todos os ouvintes de progresso\r\n    notifyProgressListeners(progressData) {\r\n        this.progressListeners.forEach(listener => listener(progressData));\r\n    }\r\n\r\n    /**\r\n     * Mostra a pergunta atual.\r\n     * @param {string} key - A chave identificando a pergunta a ser mostrada.\r\n     */\r\n    async showQuestion(key, lastAnswer = null) {\r\n        try {\r\n            const question = this.questions[key];\r\n            if (!question) throw new Error(`A pergunta com a chave ${key} não foi encontrada.`);\r\n\r\n            this.clearInputArea();\r\n\r\n            if (typeof question.text == 'function') {\r\n                await this.appendBotMessage(question.text(this.answers));\r\n            } else {\r\n                await this.appendBotMessage(question.text);\r\n            }\r\n\r\n\r\n            const renderMethod = this.getRenderMethod(question.type);\r\n            if (!renderMethod) throw new Error(`O tipo de input ${question.type} não é suportado.`);\r\n\r\n            if (question.type === \"select\") {\r\n                renderMethod.call(this, question.choices);\r\n            } else if (question.type === 'text') {\r\n                renderMethod.call(this, question.choices);\r\n            } else {\r\n                question.choices.forEach(choice => renderMethod.call(this, choice));\r\n            }\r\n            this.scrollToBottom();\r\n        } catch (error) {\r\n            this.logger.error(`Erro ao mostrar a pergunta com a chave ${key}. Verifique se a pergunta existe e se o tipo de input é suportado.`, error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtém o método de renderização apropriado com base no tipo de input.\r\n     * @param {string} type - O tipo de input.\r\n     * @return {function} - O método de renderização apropriado.\r\n     */\r\n    getRenderMethod(type) {\r\n        const renderMethods = {\r\n            'button': this.renderButton,\r\n            'select': this.renderSelect,\r\n            'text': this.renderText,\r\n            'link': this.renderLink\r\n        };\r\n        return renderMethods[type] || null;\r\n    }\r\n\r\n    /**\r\n   * Renderiza um botão como opção de resposta.\r\n   * @param {Object} choice - O objeto representando a opção de resposta.\r\n   */\r\n    renderButton(choice) {\r\n        try {\r\n            const chatInputsDynamic = this.createElement(\"div\", \"chat-inputs__dynamic\");\r\n            const button = this.createElement(\"button\", \"input--buttons\", choice.text);\r\n            button.addEventListener(\"click\", () => this.processAnswer(choice));\r\n            chatInputsDynamic.appendChild(button);\r\n            this.inputArea.appendChild(chatInputsDynamic);\r\n        } catch (error) {\r\n            this.logger.error(`Erro ao renderizar botão com o texto ${choice.text}. Verifique se o texto é uma string e se você adicionou pelo menos uma pergunta.`, error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renderiza um dropdown select como opção de resposta.\r\n     * @param {Array} choices - O array de opções a serem adicionadas ao select.\r\n     */\r\n    renderSelect(choices) {\r\n        try {\r\n            const chatInputsDynamic = this.createElement(\"div\", \"chat-inputs__dynamic\");\r\n            const select = this.createElement(\"select\", \"input--select\");\r\n            select.appendChild(\r\n                this.createElement(\"option\", null, \"Selecione uma opção\", { value: \"\" })\r\n            )\r\n            choices.forEach(option => {\r\n                let attrs = {};\r\n                if (option.attrs) {\r\n                    attrs = option.attrs;\r\n                }\r\n                attrs.value = option.value\r\n                const optionElement = this.createElement(\"option\", null, option.text, attrs);\r\n                select.appendChild(optionElement);\r\n            });\r\n            select.addEventListener(\"change\", event => this.processAnswer({\r\n                text: event.target.selectedOptions[0].text,\r\n                value: event.target.value\r\n            }));\r\n            chatInputsDynamic.appendChild(select);\r\n            this.inputArea.appendChild(chatInputsDynamic);\r\n        } catch (error) {\r\n            this.logger.error(`Erro ao renderizar select com as opções ${choices}. Verifique se o array de opções é válido e se você adicionou pelo menos uma pergunta.`, error);\r\n        }\r\n    }\r\n\r\n    // Método para adicionar máscara a inputs\r\n    maskInput(input, masks = ['(00) 0000-0000', '(00) 00000-0000']) {\r\n        // Pega o tamanho máximo da máscara\r\n        const maxMaskSize = Math.max(...masks.map(mask => mask.replace(/\\D/g, '').length));\r\n\r\n        // Adiciona um 'ouvinte' para o evento de digitar\r\n        input.addEventListener(\"input\", function (e) {\r\n            // Remove tudo que não é número\r\n            let value = this.value.replace(/\\D/g, '');\r\n\r\n            // Limita o tamanho do input\r\n            value = value.substring(0, maxMaskSize);\r\n\r\n            // Escolhe a máscara com base no comprimento do valor\r\n            let mask = masks.find(mask => mask.replace(/\\D/g, '').length >= value.length) || masks[masks.length - 1];\r\n\r\n            // Aplica a máscara\r\n            let result = '';\r\n            let index = 0;\r\n            for (let char of mask) {\r\n                if (index >= value.length) break;\r\n                if (/\\D/.test(char)) {\r\n                    result += char;\r\n                } else {\r\n                    result += value[index++];\r\n                }\r\n            }\r\n\r\n            // Atualiza o valor do input com o formato\r\n            this.value = result;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Renderiza um campo de texto como opção de resposta.\r\n     */\r\n    renderText(choices = {}) {\r\n        try {\r\n            let attrs = {};\r\n            if (choices.attrs) {\r\n                attrs = choices.attrs;\r\n            }\r\n            const chatInputsDynamic = this.createElement(\"div\", \"chat-inputs__dynamic\");\r\n            const input = this.createElement(\"input\", \"input--text\", null, attrs);\r\n\r\n            //Se o input for type tel criar mascara\r\n            if (attrs.type == \"tel\") {\r\n                this.maskInput(input, ['(00) 0000-0000', '(00) 00000-0000']);\r\n            }\r\n\r\n            //cpf ou cnpj\r\n            if (attrs.data_cpf) {\r\n                this.maskInput(input, ['000.000.000-00', '00.000.000/0000-00']);\r\n            }\r\n\r\n            //cep\r\n            if (attrs.data_cep) {\r\n                this.maskInput(input, ['00000-000']);\r\n            }\r\n\r\n            //data\r\n            if (attrs.data_data) {\r\n                this.maskInput(input, ['00/00/0000']);\r\n            }\r\n\r\n            input.addEventListener(\"change\", event => this.processAnswer({\r\n                text: event.target.value,\r\n                value: event.target.value\r\n            }));\r\n            const sendButton = this.createElement(\"button\", \"chat-inputs__send-button\", \"\");\r\n            sendButton.addEventListener(\"click\", () => this.processAnswer({\r\n                text: input.value,\r\n                value: input.value\r\n            }));\r\n            chatInputsDynamic.appendChild(input);\r\n            chatInputsDynamic.appendChild(sendButton);\r\n            this.inputArea.appendChild(chatInputsDynamic);\r\n        } catch (error) {\r\n            this.logger.error(`Erro ao renderizar input de texto com as opções ${choices}. Verifique se o array de opções é válido e se você adicionou pelo menos uma pergunta.`, error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renderiza um link como opção de resposta.\r\n     * @param {Object} choices - O objeto representando a opção de resposta.\r\n     */\r\n    renderLink(choices) {\r\n        try {\r\n            const chatInputsDynamic = this.createElement(\"div\", \"chat-inputs__dynamic\");\r\n            // Montar objeto de attributes\r\n            /*\r\n            choices.attrs = {\r\n                href: \"https://www.google.com.br\",\r\n                target: \"_blank\"\r\n\r\n            };\r\n            */\r\n\r\n            let attrs = {};\r\n            if (choices.attrs) {\r\n                attrs = choices.attrs;\r\n            }\r\n            const link = this.createElement(\"a\", \"input--link\", choices.text, choices.attrs);\r\n            link.addEventListener(\"click\", () => this.processAnswer(choices, false));\r\n            chatInputsDynamic.appendChild(link);\r\n            this.inputArea.appendChild(chatInputsDynamic);\r\n        } catch (error) {\r\n            this.logger.error(`Erro ao renderizar link com o texto ${choices.text}. Verifique se o texto é uma string e se você adicionou pelo menos uma pergunta.`, error);\r\n        }\r\n    }\r\n\r\n    /**\r\n   * Anexa uma mensagem enviada pelo bot ao log do chat.\r\n   * @param {string} message - A mensagem a ser exibida.\r\n   */\r\n    async appendBotMessage(message) {\r\n        try {\r\n            await this.appendBotTyping();\r\n            const messageElement = this.createElement(\"div\", \"bot-message\", message);\r\n            this.chatLog.appendChild(messageElement);\r\n            this.scrollToBottom();\r\n        } catch (error) {\r\n            this.logger.error(`Erro ao anexar a mensagem do bot com o texto ${message}. Verifique se o texto é uma string e se você adicionou pelo menos uma pergunta.`, error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Limpa a área de input removendo todos os elementos filhos.\r\n     */\r\n    clearInputArea() {\r\n        try {\r\n            while (this.inputArea.firstChild) {\r\n                this.inputArea.removeChild(this.inputArea.firstChild);\r\n            }\r\n        } catch (error) {\r\n            this.logger.error(\"Erro ao limpar a área de input. Verifique se você adicionou pelo menos uma pergunta.\", error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Anexa um elemento de \"digitando\" para simular que o bot está digitando uma mensagem.\r\n     */\r\n    async appendBotTyping() {\r\n        try {\r\n            const messageElement = this.createElement(\"div\", \"bot-message-typing\");\r\n            [\"dot1\", \"dot2\", \"dot3\"].forEach(id => {\r\n                const dot = this.createElement(\"span\", \"dot\", null, { id });\r\n                messageElement.appendChild(dot);\r\n            });\r\n            this.chatLog.appendChild(messageElement);\r\n            this.scrollToBottom();\r\n            await this.sleep(1000);\r\n            this.chatLog.removeChild(messageElement);\r\n        } catch (error) {\r\n            this.logger.error(\"Erro ao anexar o elemento de 'digitando'\", error)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processa a resposta fornecida pelo usuário e passa para a próxima pergunta.\r\n     * @param {Object} answer - A resposta fornecida pelo usuário.\r\n     */\r\n    async processAnswer(answer, appendOnChat = true) {\r\n        try {\r\n            this.storeAnswer(this.currentQuestion, answer);\r\n\r\n            if (appendOnChat) {\r\n                await this.appendUserMessage(answer.text);\r\n            }\r\n            const nextQuestion = await this.getNextQuestionKey(answer);\r\n\r\n            const progressData = {\r\n                currentQuestion: this.currentQuestion,\r\n                answer: answer,\r\n                nextQuestion: nextQuestion,\r\n                answers: this.answers\r\n            };\r\n\r\n            // Notifica ouvintes de progresso\r\n            this.notifyProgressListeners(progressData);\r\n\r\n            if (nextQuestion) {\r\n                this.currentQuestion = nextQuestion;\r\n                this.showQuestion(this.currentQuestion, answer);\r\n            } else {\r\n                // Lógica para encerrar a conversa\r\n                // Você também pode chamar `this.notifyProgressListeners` aqui com dados indicando que a conversa terminou\r\n            }\r\n        } catch (error) {\r\n            this.logger.error(\"Erro ao processar a resposta\", error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Armazena a resposta do usuário em um objeto de respostas.\r\n     * @param {string} key - A chave da pergunta atual.\r\n     * @param {Object} answer - A resposta fornecida pelo usuário.\r\n     */\r\n    storeAnswer(key, answer) {\r\n        this.answers[key] = answer;\r\n    }\r\n\r\n    /**\r\n     * Obtém a chave para a próxima pergunta com base na resposta do usuário.\r\n     * @param {Object} answer - A resposta fornecida pelo usuário.\r\n     * @return {string|null} - A chave para a próxima pergunta ou null.\r\n     */\r\n    async getNextQuestionKey(answer) {\r\n        const currentQuestion = this.questions[this.currentQuestion];\r\n        if (currentQuestion.nextQuestion) {\r\n            return currentQuestion.nextQuestion(answer);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Anexa uma mensagem enviada pelo usuário ao log do chat.\r\n     * @param {string} message - A mensagem a ser exibida.\r\n     */\r\n    async appendUserMessage(message) {\r\n        try {\r\n            const messageElement = this.createElement(\"div\", \"user-message\", message);\r\n            this.chatLog.appendChild(messageElement);\r\n            this.scrollToBottom();\r\n        } catch (error) {\r\n            this.logger.error(\"Erro ao anexar a mensagem do usuário\", error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rola o Chat Lot para o final\r\n     */\r\n    scrollToBottom() {\r\n        if (this.chatLog) {\r\n            this.chatLog.scrollTop = this.chatLog.scrollHeight;\r\n        } else {\r\n            this.logger.error(\"Erro ao rolar o chat para o final. Verifique se você adicionou o elemento #mkt-chatbot-log no DOM.\")\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cria um novo elemento DOM.\r\n     * @param {string} tag - O tipo do elemento.\r\n     * @param {string} className - A classe CSS do elemento.\r\n     * @param {string} textContent - O conteúdo de texto do elemento.\r\n     * @param {Object} attributes - Outros atributos do elemento.\r\n     * @return {HTMLElement} - O elemento DOM criado.\r\n     */\r\n    createElement(tag, className, textContent, attributes = {}) {\r\n        const element = document.createElement(tag);\r\n        if (className) element.className = className;\r\n        if (textContent) element.textContent = textContent;\r\n        Object.keys(attributes).forEach(key => element.setAttribute(key, attributes[key]));\r\n        return element;\r\n    }\r\n\r\n    /**\r\n     * Pausa a execução por um determinado número de milissegundos.\r\n     * @param {number} ms - O número de milissegundos para pausar.\r\n     * @return {Promise} - Uma promessa que se resolve após o tempo especificado.\r\n     */\r\n    sleep(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n\r\n    /**\r\n     * Abre o chat e oculta o ícone do chat.\r\n     */\r\n    openChat() {\r\n        try {\r\n            this.logger.debug(\"Para fechar clique no botão de minimizar.\");\r\n            this.chatIcon.classList.add(\"hidden\");\r\n            this.chatMain.classList.remove(\"hidden\");\r\n        } catch (error) {\r\n            this.logger.error(\"Erro ao abrir o chat. Verifique se você adicionou os elementos #mkt-chatbot-icon e #mkt-chatbot no DOM.\", error)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Minimiza o chat e mostra o ícone do chat.\r\n     */\r\n    minimizeChat() {\r\n        try {\r\n            this.chatMain.style.animation = \"slide-fade-out 0.5s ease forwards\";\r\n            this.chatMain.addEventListener('animationend', () => {\r\n                this.chatMain.classList.add(\"hidden\");\r\n                this.chatMain.style.animation = '';  // Limpa a animação\r\n            }, { once: true });  // O evento só será disparado uma vez\r\n            this.chatIcon.classList.remove(\"hidden\");\r\n        } catch (error) {\r\n            this.logger.error(\"Erro ao minimizar o chat. Verifique se você adicionou os elementos #mkt-chatbot-icon e #mkt-chatbot no DOM.\", error);\r\n        }\r\n    }\r\n\r\n}"],"names":["ChatBot","constructor","this","logger","Logger","initDOMElements","initDOMEvents","questions","currentQuestion","answers","progressListeners","error","chatWrapper","document","getElementById","chatIcon","querySelector","chatMain","minimizeButton","chatLog","inputArea","addEventListener","openChat","minimizeChat","start","showQuestion","classList","remove","addQuestion","key","text","type","choices","nextQuestion","warn","addProgressListener","listener","push","notifyProgressListeners","progressData","forEach","lastAnswer","question","Error","clearInputArea","await","appendBotMessage","renderMethod","getRenderMethod","call","choice","scrollToBottom","button","renderButton","select","renderSelect","renderText","link","renderLink","chatInputsDynamic","createElement","processAnswer","appendChild","value","option","let","attrs","optionElement","event","target","selectedOptions","maskInput","input","masks","maxMaskSize","Math","max","map","mask","replace","length","e","char","substring","result","index","find","test","data_cpf","data_cep","data_data","sendButton","message","appendBotTyping","messageElement","firstChild","removeChild","id","dot","sleep","answer","appendOnChat","storeAnswer","appendUserMessage","getNextQuestionKey","scrollTop","scrollHeight","tag","className","textContent","attributes","element","Object","keys","setAttribute","ms","Promise","resolve","setTimeout","debug","add","style","animation","once"],"mappings":"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"}